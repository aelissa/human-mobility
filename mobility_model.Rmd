---
title: "Movement Across Tiles -- Prediction"
output: html_notebook
---

#### Grid Pre-processing (can be skipped, output saved)
```{r}
library(sf)
library(tidyverse)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(terra)

grid<-st_read("~/itinerant/facebook_allBritain/grid/grid.gpkg") 

#add gridded population

pop_grid<-st_read("~/itinerant/pop_data/grids_layer/vector_grid.shp")
pop_data<-read_csv("~/itinerant/pop_data/data2011_complete.csv")

pop_grid<-pop_grid %>%
  inner_join(pop_data,by=c("ID"="grid_ID"))
remove(pop_data)

FBgridWpop <- st_interpolate_aw(pop_grid, st_transform(grid,27700), extensive = T)
FBgridWpop_final<-FBgridWpop %>%
  select(Population) %>%
  mutate(quadkey=grid$strt_qd) 

### 662837.8 people missing!
#add cluster 
cluster_proportions_labels <- read_csv("~/itinerant/grid_clustering/cluster_proportions_labels.csv")

cluster_proportions_labels <- cluster_proportions_labels %>%
  rename(quadkey=index)

####merge all

FBgridWpop_final<-FBgridWpop_final %>%
  inner_join(cluster_proportions_labels,by=c("quadkey"="quadkey"))
st_write(FBgridWpop_final, "~/itinerant/FBgridPop.shp")
```
<!-- ### Movements within GLA -->

<!-- ```{r} -->
<!-- movementsGLA<-movements %>% -->
<!--   filter(start_quadkey %in% grid$quadkey & end_quadkey %in% grid$quadkey) %>% -->
<!--   mutate( -->
<!--     hour=substr(date_time,nchar(date_time)-5,nchar(date_time)-3), -->
<!--     monthDay=(format(as.Date(date_time), "%d-%m")), -->
<!--     wday=wday(date_time,label = T), -->
<!--     wd=ifelse(wday=="Sun"|wday=="Sat","Weekend","Weekday"), -->
<!--     wd=ifelse(date_time=="2021-08-30 00:00" | date_time=="2021-08-30 08:00" | date_time=="2021-08-30 16:00", "Weekend", wd))%>% -->
<!--   select(start_quadkey,end_quadkey,start_lat,start_lon,end_lat,end_lon,hour,wday,wd,monthDay,n_crisis) %>% -->
<!--   rename(n_movements=n_crisis) %>% -->
<!--   inner_join(population[c("quadkey","n_pop","hour","wday")],by=c("start_quadkey"="quadkey","hour"="hour","wday"="wday"))%>% -->
<!--   rename(start_pop=n_pop)%>% -->
<!--   inner_join(population[c("quadkey","n_pop","hour","wday")],by=c("end_quadkey"="quadkey","hour"="hour","wday"="wday"))%>% -->
<!--   rename(end_pop=n_pop) -->

<!-- start<-st_as_sf(movementsGLA,coords = c("start_lon", "start_lat"), crs = 4326) -->
<!-- end<-st_as_sf(movementsGLA,coords = c("end_lon", "end_lat"), crs = 4326) -->
<!-- dist<-st_distance(start,end,by_element = T)   -->
<!-- movementsGLA$dist<-dist -->
<!-- remove(start,end,dist) -->

<!-- movementsGLA<-movementsGLA %>% -->
<!--   inner_join(st_drop_geometry(grid[c("quadkey","clusters")]),by=c("start_quadkey"="quadkey")) %>% -->
<!--   rename(start_cluster=clusters) %>% -->
<!--   inner_join(st_drop_geometry(grid[c("quadkey","clusters")]),by=c("end_quadkey"="quadkey")) %>% -->
<!--   rename(end_cluster=clusters) -->

<!-- movementsGLA<-movementsGLA[!is.na(movementsGLA$n_movements),] -->
<!-- movementsGLA$n_movements<-as.integer(movementsGLA$n_movements) -->

<!-- ``` -->

### Prepare data for modelling
```{r}
#Load final grid
grid<-st_read("~/itinerant/FBgridPop.shp")
#Load Movements data
files<-list.files("~/itinerant/facebook_allBritain/movements/july-august-2021/",full.names = T)
files<-append(files,list.files("~/itinerant/facebook_allBritain/movements/march-april-2020/",full.names = T))
movements<-files %>% purrr::map_dfr(~ read_csv(.x, col_types = cols(date_time = col_character(),start_quadkey= col_character(),end_quadkey= col_character())))

#Load Population
files_p<-list.files("~/itinerant/facebook_allBritain/population/july-august-2021/",full.names = T)
files_p<-append(files_p,list.files("~/itinerant/facebook_allBritain/population/march-april-2020/",full.names = T))
population<-files_p %>% purrr::map_dfr(~ read_csv(.x, col_types = cols(date_time = col_character(),quadkey= col_character())))

movements <- movements %>%
  mutate(
    hour=substr(date_time,nchar(date_time)-5,nchar(date_time)-3),
    date=as.Date(strftime(date_time, "%Y-%m-%d", tz="GMT")),
    wday=wday(date_time,label = T),
    wd=ifelse(wday=="Sun"|wday=="Sat","Weekend","Weekday"),
    time_interval=ifelse(date>"2021-01-01",2,1))

population<-population %>%
  mutate(
    hour=substr(date_time,nchar(date_time)-5,nchar(date_time)-3),
    date=as.Date(strftime(date_time, "%Y-%m-%d", tz="GMT")),
    wday=wday(date_time,label = T),
    wd=ifelse(wday=="Sun"|wday=="Sat","Weekend","Weekday"),
    time_interval=ifelse(date>"2021-01-01",2,1))

population<-population %>% 
  mutate(
quadkey=substr(quadkey,0,nchar(quadkey)-1)
  )%>%
  group_by(wday,hour,date,quadkey) %>%
  dplyr::summarise(n_pop=sum(n_crisis,na.rm=T))

###this is to get points coordinates and calculate distance
grid_centroids<-st_centroid(grid)
grid_centroids<-cbind(grid_centroids,st_coordinates(grid_centroids))

  
movements_population_cluster<-movements %>%
  select(start_quadkey,end_quadkey,hour,date,wday,wd,time_interval) %>%
  inner_join(population[c("quadkey","n_pop","hour","date")],by=c("start_quadkey"="quadkey","hour"="hour","date"="date")) %>%
  rename(start_FBpop=n_pop) %>%
  inner_join(population[c("quadkey","n_pop","hour","date")],by=c("end_quadkey"="quadkey","hour"="hour","date"="date")) %>%
  rename(end_FBpop=n_pop) %>%
  inner_join(st_drop_geometry(grid_centroids[c("Popultn","quadkey","label","X","Y")]),by=c("start_quadkey"="quadkey")) %>%
  rename(start_pop=Popultn,
         start_cluster=label,
         start_lon=X,
         start_lat=Y) %>%
  inner_join(st_drop_geometry(grid_centroids[c("Popultn","quadkey","label","X","Y")]),by=c("end_quadkey"="quadkey")) %>%
  rename(end_pop=Popultn,
         end_cluster=label,
         end_lon=X,
         end_lat=Y)

#calculate distance across different tiles, only unique values are pick to reduce computation time

calculate_distance<-unique(movements_population_cluster[c("start_quadkey","end_quadkey","start_lon","start_lon","start_lat","end_lon","end_lat")]) 
calculate_distance$same<-ifelse(calculate_distance$start_quadkey==calculate_distance$end_quadkey,1,0)
calculate_distance<-calculate_distance[calculate_distance$same==0,]
  
start<-st_as_sf(calculate_distance[c("start_lon","start_lat")],coords = c("start_lon","start_lat"))
end<-st_as_sf(calculate_distance[c("end_lon","end_lat")],coords = c("end_lon","end_lat"))
dist<-st_distance(start,end,by_element = T)
calculate_distance$d<-dist

###join distance based on cluster pairs
movements_population_cluster_distance<-movements_population_cluster %>%
  full_join(calculate_distance[c("start_quadkey","end_quadkey","d")],by=(c("start_quadkey"="start_quadkey","end_quadkey"="end_quadkey")))

####when distance is na there is intramobility
movements_population_cluster_distance$d<-ifelse(is.na(movements_population_cluster_distance$d),0,movements_population_cluster_distance$d)


saveRDS(movements_population_cluster_distance,"~/itinerant/pre-processed-movements/movements.rds")
```


### Multinomial logistic regression (does not work)

```{r}
library(mnlogit)
###doesn't work :) needs to be reformulated as to deal with aggregated data

movementsGLA_individuals<-movementsGLA %>%
  uncount(n_movements)
movementsGLA_individuals$id<-seq(1:nrow(movementsGLA_individuals))
 movementsGLA_individuals$mov<-as.factor(paste0(movementsGLA_individuals$start_quadkey,movementsGLA_individuals$end_quadkey))
 
 movementsGLA_individuals$func<-as.factor(paste0(movementsGLA_individuals$start_cluster,movementsGLA_individuals$end_cluster))
 
 ml_data<-mlogit::mlogit.data(movementsGLA_individuals,choice = "func",shape = "wide")


```
### Binomial Logistic Regression (aggregate data)

```{r}

scale_2sd<-function(x){(x - mean(x)) / 2*sd(x)}
scale_sd<-function(x){(x - mean(x)) / sd(x)}

movementsGLA_model<-movementsGLA %>%
  mutate(prop_mov=n_movements/start_pop,
         clusterPair=paste0(start_cluster,"_",end_cluster),
         clusterPairTime=paste0(clusterPair,"_",wd,"_",hour),
         across(.cols = c("start_pop","end_pop","dist"),scale_2sd))

eq <- prop_mov ~ start_cluster:end_cluster + start_pop + end_pop + dist 
m <- glm(eq,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m)

eq1 <- prop_mov ~ clusterPair + start_pop + end_pop + dist  
m1 <- glm(eq1,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m1)

clusters_interaction <- data.frame(clusterPair = unique(movementsGLA_model$clusterPair))
clusters_interaction<-clusters_interaction %>%
  mutate(
    dist=mean(movementsGLA$dist),
    start_pop=mean(movementsGLA$start_pop),
    end_pop=mean(movementsGLA$end_pop))
clusters_interaction$probs<-predict(m1, newdata = clusters_interaction, "response")
clusters_interaction$probs<-plogis(predict(m1, newdata = clusters_interaction, "response"))

movementsGLA_model<-movementsGLA %>%
  mutate(is_diagonal=ifelse(start_cluster==end_cluster,1,0))%>%
  filter(is_diagonal!=1) %>%
  mutate(prop_mov=n_movements/start_pop,
         clusterPair=paste0(start_cluster,"_",end_cluster),
         clusterPairTime=paste0(clusterPair,"_",wd,"_",hour),
         across(.cols = c("start_pop","end_pop","dist"),scale_2sd))

movementsGLA<-movementsGLA %>%
  mutate(is_diagonal=ifelse(start_cluster==end_cluster,1,0))

eq2 <- prop_mov ~ clusterPair + start_pop + end_pop + dist  
m2 <- glm(eq2,
          data=movementsGLA_model,
          weights = movementsGLA[movementsGLA$is_diagonal!=1,]$start_pop, 
          family = binomial("logit"))

summary(m2)

clusters_interaction_noD <- data.frame(clusterPair = unique(movementsGLA_model$clusterPair))
clusters_interaction_noD<-clusters_interaction %>%
  mutate(
    dist=mean(movementsGLA[movementsGLA$is_diagonal!=1,]$dist),
    start_pop=mean(movementsGLA[movementsGLA$is_diagonal!=1,]$start_pop),
    end_pop=mean(movementsGLA[movementsGLA$is_diagonal!=1,]$end_pop))
clusters_interaction_noD$probs<-predict(m2, newdata = clusters_interaction_noD, "response")
clusters_interaction_noD$probs<-plogis(predict(m1, newdata = clusters_interaction_noD, "response"))

eq3 <- prop_mov ~ clusterPairTime + start_pop + end_pop + dist

m3 <- glm(eq3,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m3)
clusters_interaction_time <- data.frame(clusterPairTime = unique(movementsGLA_model$clusterPairTime))
clusters_interaction_time<-clusters_interaction_time %>%
  mutate(
    dist=mean(movementsGLA$dist),
    start_pop=mean(movementsGLA$start_pop),
    end_pop=mean(movementsGLA$end_pop))
clusters_interaction_time$probs<-plogis(predict(m3, newdata = clusters_interaction_time, "response"))
clusters_interaction_time$lodds<-predict(m3, newdata = clusters_interaction_time, "response")

clusters_interaction_time<-clusters_interaction_time %>%
  separate(clusterPairTime,sep="_",c("start","end","wd","hour"))%>%
  inner_join(cluster_code,by=c("start"="cluster"))%>%
  rename(start_code=code)%>%
  inner_join(cluster_code,by=c("end"="cluster"))%>%
  rename(end_code=code)
  

ggplot(clusters_interaction_time, aes(x=start_code,y=end_code,fill=probs))+
  geom_tile()+
  facet_wrap(~ wd + hour)



m4 <- glm(eq4,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))



```
### Multilevel models with random effect

```{r}
library(lme4)
library(merTools)

movementsGLA_model<-movementsGLA %>%
  mutate(prop_mov=n_movements/start_pop,
         clusterPair=paste0(start_cluster,"_",end_cluster),
         clusterPairTime=paste0(clusterPair,"_",wd,"_",hour),
         across(.cols = c("start_pop","end_pop","dist"),scale)) ###it does not like the 2sd scaling

eq4<-prop_mov ~ (1 | start_quadkey) + clusterPair + start_pop + end_pop + dist
m4 <- lmer(eq4, data = movementsGLA_model)
plotREsim(REsim(m4))
summary(m4)

eq5<-prop_mov ~ (1 | clusterPair) + start_pop + end_pop + dist
m5 <- lmer(eq5, data = movementsGLA_model)
plotREsim(REsim(m5))
summary(m5)

re_m5 <- REsim(m5) %>% filter(groupFctr == "clusterPair") 

eq6<-prop_mov ~  hour + (1 + hour | clusterPair) + start_pop + end_pop + dist
m6 <- lmer(eq6, data = movementsGLA_model) 
plotREsim(REsim(m6))
summary(m6)

eq7<-prop_mov ~ (1 | hour)+(1 | clusterPair) +start_pop + end_pop + dist
m7 <- lmer(eq7, data = movementsGLA_model) 
plotREsim(REsim(m7))

eq8<-prop_mov ~ (1 | hour:clusterPair) + start_pop + end_pop + dist
m8 <- lmer(eq8, data = movementsGLA_model) 
plotREsim(REsim(m8))

library(glmer)
```



### Markow Chains

```{r}
library(markovchain)

cluster<-unique(movementsGLA$start_cluster)

code<-LETTERS[seq( from = 1, to = 8 )]

cluster_code<-data.frame(cluster,code)

####looping across time and day of week
week<-c("Weekday","Weekend")
time<-c(" 00"," 08"," 16")
i=0
plots<-list()

for(w in week){
  for(t in time){
    i=i+1
    tot_by_cluster<-movementsGLA %>%
      filter(wd==w & hour==t) %>%
      group_by(end_cluster)%>%
      summarise(tot_movements=sum(n_movements,na.rm = T))
    m<-movementsGLA %>%
          filter(wd==w & hour==t) %>%
          group_by(start_cluster,end_cluster)%>%
          dplyr::summarise(n_movements=sum(n_movements, na.rm=T))%>%
          inner_join(tot_by_cluster,by=c("end_cluster"="end_cluster"))%>%
          mutate(prob=n_movements/tot_movements) %>%
          inner_join(cluster_code,by=c("start_cluster"="cluster"))%>%
          rename(start_code=code)%>%
          inner_join(cluster_code,by=c("end_cluster"="cluster"))%>%
          rename(end_code=code)
    p<-ggplot(m,aes(x=start_code,y=end_code,fill=prob)) +
            geom_tile() +
            theme_bw()
    plots[[i]]<-p
  }
}

P<-ggarrange(plots[[1]],plots[[2]],plots[[3]],plots[[4]],plots[[5]],plots[[6]],labels=c("WD 00","WD 08","WD 16","WE 00","WE 08","WE 16"),nrow = 2,ncol = 3,hjust = 0.1,font.label = list(size=11))

ggsave("/home/alessia/itinerant/img/transitions.jpg",P,units = "cm",width = 30,height = 15)

plots_noD<-list()
i=0

for(w in week){
  for(t in time){
    i=i+1
    tot_by_cluster<-movementsGLA %>%
      filter(wd==w & hour==t) %>%
      group_by(end_cluster)%>%
      summarise(tot_movements=sum(n_movements,na.rm = T))
    m<-movementsGLA %>%
          filter(wd==w & hour==t) %>%
          group_by(start_cluster,end_cluster)%>%
          dplyr::summarise(n_movements=sum(n_movements, na.rm=T))%>%
          inner_join(tot_by_cluster,by=c("end_cluster"="end_cluster"))%>%
          mutate(prob=n_movements/tot_movements) %>%
          inner_join(cluster_code,by=c("start_cluster"="cluster"))%>%
          rename(start_code=code)%>%
          inner_join(cluster_code,by=c("end_cluster"="cluster"))%>%
          rename(end_code=code)
    p<-ggplot(m[m$prob<0.7,],aes(x=start_code,y=end_code,fill=prob)) +
            geom_tile() +
            theme_bw()
    plots_noD[[i]]<-p
  }
}

P_noD<-ggarrange(plots_noD[[1]],plots_noD[[2]],plots_noD[[3]],plots_noD[[4]],plots_noD[[5]],plots_noD[[6]],labels=c("WD 00","WD 08","WD 16","WE 00","WE 08","WE 16"),nrow = 2,ncol = 3,hjust = 0.1,font.label = list(size=11))


transition_M<-matrix(movementsGLA_m_WD08$prob,nrow = 8,byrow = T)
transition_M<-matrix(transition_M,nrow=8,byrow=T,dimname=list(cluster, cluster)) #this can be function to function
MC<-new("markovchain",states= tiles,byrow=T,transitionMatrix=transition_M,name="movements")
ST<-steadyStates(MC)
```

### Spatial Interaction Model

```{r}

movementGLA_SI<-movementsGLA %>%
  select(start_cluster,end_cluster,n_movements,dist,start_pop,end_pop,wd,monthDay)%>%
  mutate(dummy=1,
         id=seq(1:nrow(movementsGLA))) %>%
  pivot_wider(id_cols = c("n_movements","dist","start_pop","end_pop","wd","monthDay"),
              names_from = ends_with("cluster"),values_from = "dummy")

movementGLA_SI[is.na(movementGLA_SI)] = 0

lm(formula=log(n_movements)+0.001~dist+`Suburban/commuters_Towns/Discontinuous urban fabrics`+`Industrial and manufacturing_Urban residential and other work`, movementGLA_SI)

```


















