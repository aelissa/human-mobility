---
title: "Movement Across Tiles -- Prediction"
output: html_notebook
---

```{r}
library(sf)
library(tidyverse)
library(lubridate)
library(ggplot2)
library(ggpubr)

#Load Movements data
files<-list.files("~/itinerant/movements_facebook/",full.names = T)
movements<-files %>% purrr::map_dfr(~ read_csv(.x, col_types = cols(date_time = col_character())))
#Load Population
files_p<-list.files("~/itinerant/population_facebook/",full.names = T)
population<-files_p %>% purrr::map_dfr(~ read_csv(.x, col_types = cols(date_time = col_character()))) %>%
  mutate(
    hour=substr(date_time,nchar(date_time)-5,nchar(date_time)-3),
    wday=wday(date_time,label = T),
    wd=ifelse(wday=="Sun"|wday=="Sat","Weekend","Weekday"),
    wd=ifelse(date_time=="2021-08-30 00:00" | date_time=="2021-08-30 08:00" | date_time=="2021-08-30 16:00", "Weekend", wd),
    quadkey=substr(quadkey,0,nchar(quadkey)-1)
  )%>%
  group_by(wday,hour,quadkey) %>%
  dplyr::summarise(n_pop=sum(n_crisis,na.rm=T))

grid<-st_read("~/itinerant/grid_GLA.gpkg") 
#add quadkey att
quadkey_centroid<-unique(movements[c("start_lon","start_lat","start_quadkey")]) %>%
  st_as_sf(coords = c("start_lon", "start_lat"), crs = 4326) %>%
  st_transform(27700) %>%
  rename(
    quadkey=start_quadkey
  )
grid<-st_join(grid, quadkey_centroid,join=st_intersects)
grid_F<-st_read("~/itinerant/FB_GRID_CLUSTERNAMES.geojson")
grid<-inner_join(grid,st_drop_geometry(grid_F[c("id","clusters")]),by=c("id"="id"))
```
### Movements within GLA

```{r}
movementsGLA<-movements %>%
  filter(start_quadkey %in% grid$quadkey & end_quadkey %in% grid$quadkey) %>%
  mutate(
    hour=substr(date_time,nchar(date_time)-5,nchar(date_time)-3),
    monthDay=(format(as.Date(date_time), "%d-%m")),
    wday=wday(date_time,label = T),
    wd=ifelse(wday=="Sun"|wday=="Sat","Weekend","Weekday"),
    wd=ifelse(date_time=="2021-08-30 00:00" | date_time=="2021-08-30 08:00" | date_time=="2021-08-30 16:00", "Weekend", wd))%>%
  select(start_quadkey,end_quadkey,start_lat,start_lon,end_lat,end_lon,hour,wday,wd,monthDay,n_crisis) %>%
  rename(n_movements=n_crisis) %>%
  inner_join(population[c("quadkey","n_pop","hour","wday")],by=c("start_quadkey"="quadkey","hour"="hour","wday"="wday"))%>%
  rename(start_pop=n_pop)%>%
  inner_join(population[c("quadkey","n_pop","hour","wday")],by=c("end_quadkey"="quadkey","hour"="hour","wday"="wday"))%>%
  rename(end_pop=n_pop)

start<-st_as_sf(movementsGLA,coords = c("start_lon", "start_lat"), crs = 4326)
end<-st_as_sf(movementsGLA,coords = c("end_lon", "end_lat"), crs = 4326)
dist<-st_distance(start,end,by_element = T)  
movementsGLA$dist<-dist
remove(start,end,dist)

movementsGLA<-movementsGLA %>%
  inner_join(st_drop_geometry(grid[c("quadkey","clusters")]),by=c("start_quadkey"="quadkey")) %>%
  rename(start_cluster=clusters) %>%
  inner_join(st_drop_geometry(grid[c("quadkey","clusters")]),by=c("end_quadkey"="quadkey")) %>%
  rename(end_cluster=clusters)

movementsGLA<-movementsGLA[!is.na(movementsGLA$n_movements),]
movementsGLA$n_movements<-as.integer(movementsGLA$n_movements)

```
### Multinomial logistic regression (does not work)

```{r}
library(mnlogit)
###doesn't work :) needs to be reformulated as to deal with aggregated data

movementsGLA_individuals<-movementsGLA %>%
  uncount(n_movements)
movementsGLA_individuals$id<-seq(1:nrow(movementsGLA_individuals))
 movementsGLA_individuals$mov<-as.factor(paste0(movementsGLA_individuals$start_quadkey,movementsGLA_individuals$end_quadkey))
 
 movementsGLA_individuals$func<-as.factor(paste0(movementsGLA_individuals$start_cluster,movementsGLA_individuals$end_cluster))
 
 ml_data<-mlogit::mlogit.data(movementsGLA_individuals,choice = "func",shape = "wide")


```
### Binomial Logistic Regression (aggregate data)

```{r}

scale_2sd<-function(x){(x - mean(x)) / 2*sd(x)}

movementsGLA_model<-movementsGLA %>%
  mutate(prop_mov=n_movements/start_pop,
         clusterPair=paste0(start_cluster,"_",end_cluster),
         clusterPairTime=paste0(clusterPair,"_",wd,"_",hour),
         across(.cols = c("start_pop","end_pop","dist"),scale_2sd))

eq <- prop_mov ~ start_cluster:end_cluster + start_pop + end_pop + dist 
m <- glm(eq,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m)

eq1 <- prop_mov ~ clusterPair + start_pop + end_pop + dist  
m1 <- glm(eq1,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m1)

clusters_interaction <- data.frame(clusterPair = unique(movementsGLA_model$clusterPair))
clusters_interaction<-clusters_interaction %>%
  mutate(
    dist=mean(movementsGLA$dist),
    start_pop=mean(movementsGLA$start_pop),
    end_pop=mean(movementsGLA$end_pop))
clusters_interaction$probs<-predict(m1, newdata = clusters_interaction, "response")


eq3 <- prop_mov ~ clusterPairTime + start_pop + end_pop + dist

m3 <- glm(eq3,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))

summary(m3)
clusters_interaction_time <- data.frame(clusterPairTime = unique(movementsGLA_model$clusterPairTime))
clusters_interaction_time<-clusters_interaction_time %>%
  mutate(
    dist=mean(movementsGLA$dist),
    start_pop=mean(movementsGLA$start_pop),
    end_pop=mean(movementsGLA$end_pop))
clusters_interaction_time$probs<-plogis(predict(m4, newdata = clusters_interaction_time, "response"))
clusters_interaction_time$lodds<-predict(m4, newdata = clusters_interaction_time, "response")

clusters_interaction_time<-clusters_interaction_time %>%
  separate(clusterPairTime,sep="_",c("start","end","wd","hour"))%>%
  inner_join(cluster_code,by=c("start"="cluster"))%>%
  rename(start_code=code)%>%
  inner_join(cluster_code,by=c("end"="cluster"))%>%
  rename(end_code=code)
  

ggplot(clusters_interaction_time, aes(x=start_code,y=end_code,fill=probs))+
  geom_tile()+
  facet_wrap(~ wd + hour)



m4 <- glm(eq4,
          data=movementsGLA_model,
          weights = movementsGLA$start_pop, 
          family = binomial("logit"))



```
### Multilevel models with random effect

```{r}
library(lme4)
library(merTools)

movementsGLA_model<-movementsGLA %>%
  mutate(prop_mov=n_movements/start_pop,
         clusterPair=paste0(start_cluster,"_",end_cluster),
         clusterPairTime=paste0(clusterPair,"_",wd,"_",hour),
         across(.cols = c("start_pop","end_pop","dist"),scale)) ###it does not like the 2sd scaling

eq4<-prop_mov ~ (1 | start_quadkey) + clusterPair + start_pop + end_pop + dist
m4 <- lmer(eq4, data = movementsGLA_model)
plotREsim(REsim(m4))
summary(m4)

eq5<-prop_mov ~ (1 | clusterPair) + start_pop + end_pop + dist
m5 <- lmer(eq5, data = movementsGLA_model)
plotREsim(REsim(m5))
summary(m5)

re_m5 <- REsim(m5) %>% filter(groupFctr == "clusterPair") 

eq6<-prop_mov ~  hour + (1 + hour | clusterPair) + start_pop + end_pop + dist
m6 <- lmer(eq6, data = movementsGLA_model) 
plotREsim(REsim(m6))
summary(m6)



```



### Markow Chains

```{r}
library(markovchain)

cluster<-unique(movementsGLA$start_cluster)

code<-LETTERS[seq( from = 1, to = 8 )]

cluster_code<-data.frame(cluster,code)

####looping across time and day of week
week<-c("Weekday","Weekend")
time<-c(" 00"," 08"," 16")
i=0
plots<-list()

for(w in week){
  for(t in time){
    i=i+1
    tot_by_cluster<-movementsGLA %>%
      filter(wd==w & hour==t) %>%
      group_by(end_cluster)%>%
      summarise(tot_movements=sum(n_movements,na.rm = T))
    m<-movementsGLA %>%
          filter(wd==w & hour==t) %>%
          group_by(start_cluster,end_cluster)%>%
          dplyr::summarise(n_movements=sum(n_movements, na.rm=T))%>%
          inner_join(tot_by_cluster,by=c("end_cluster"="end_cluster"))%>%
          mutate(prob=n_movements/tot_movements) %>%
          inner_join(cluster_code,by=c("start_cluster"="cluster"))%>%
          rename(start_code=code)%>%
          inner_join(cluster_code,by=c("end_cluster"="cluster"))%>%
          rename(end_code=code)
    p<-ggplot(m,aes(x=start_code,y=end_code,fill=prob)) +
            geom_tile() +
            theme_bw()
    plots[[i]]<-p
  }
}

P<-ggarrange(plots[[1]],plots[[2]],plots[[3]],plots[[4]],plots[[5]],plots[[6]],labels=c("WD 00","WD 08","WD 16","WE 00","WE 08","WE 16"),nrow = 2,ncol = 3,hjust = 0.1,font.label = list(size=11))

ggsave("/home/alessia/itinerant/img/transitions.jpg",P,units = "cm",width = 30,height = 15)

transition_M<-matrix(movementsGLA_m_WD08$prob,nrow = 8,byrow = T)
transition_M<-matrix(transition_M,nrow=8,byrow=T,dimname=list(cluster, cluster)) #this can be function to function
MC<-new("markovchain",states= tiles,byrow=T,transitionMatrix=transition_M,name="movements")
ST<-steadyStates(MC)
```

### Spatial Interaction Model

```{r}

movementGLA_SI<-movementsGLA %>%
  select(start_cluster,end_cluster,n_movements,dist,start_pop,end_pop,wd,monthDay)%>%
  mutate(dummy=1,
         id=seq(1:nrow(movementsGLA))) %>%
  pivot_wider(id_cols = c("n_movements","dist","start_pop","end_pop","wd","monthDay"),
              names_from = ends_with("cluster"),values_from = "dummy")

movementGLA_SI[is.na(movementGLA_SI)] = 0

lm(formula=log(n_movements)+0.001~dist+`Suburban/commuters_Towns/Discontinuous urban fabrics`+`Industrial and manufacturing_Urban residential and other work`, movementGLA_SI)

```


















