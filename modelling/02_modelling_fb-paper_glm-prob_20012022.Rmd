---
title: "Regression Modelling Using Facebook Data"
subtitle: " "
author: Francisco Rowe
output: html_notebook
---

Dependencies
```{r, message=FALSE, warning=FALSE}
#data wrangling
library(multidplyr) 
library(tidyverse) 
library(dplyr) 
# estimating mixed effects models 
library(lme4) 
library(merTools) 
#library(glmmTMB) 
#library(nlme)
#library(rstanarm)
# data visualisation 
library(viridis)
library(viridisLite)
library(ggthemes)
library(ggpubr)
  # reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
```

The code first obtains all the regression coefficients for the 2020 and 2021 periods separately, and then creates the plot.

# Monthly models for the 2020 period

## Data
A cross-section should provide a max set of 6080 * 6079 pairs of origin-destination, including intra-mobility
```{r}
rm(list=ls())

cluster <- new_cluster(6)

df <- readRDS("/Volumes/ITINERANT/pre-processed-movements/modelling/full_period_mov_pop.rds") %>% 
  filter(date < "2020-04-30") %>% 
  select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )

# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name)) 
destination <- as.data.frame(unique(df$end_polygon_name))

str(df)
```

## Data Wrangling

Proportion of people moving
```{r}
df <- df %>% mutate(
  mov_prop = n_crisis / start_pop
) %>% 
  filter(mov_prop <= 1)
  
```


Creating area class interaction variable
```{r}
df <-  df %>% mutate(
origin_class = ordered(origin_class, 
                      levels = c("1","2","3","4","5","6","7","8","9","10")),
destination_class = ordered(destination_class, 
                           levels = c("1","2","3","4","5","6","7","8","9","10")),
wd = factor(wd,
            levels = c("Weekday", "Weekend"))
)

df$origin_destination_class <- fct_cross(df$origin_class, df$destination_class)
df$day <- as.numeric(ordered(df$date))
df$month <- lubridate::month(lubridate::ymd(df$date), label=TRUE)
month <- unique(df$month)
df$monthyear = lubridate::floor_date(df$date, "month")
monthyear <- unique(df$monthyear)
```

Standardising covariates
```{r}
df$z_origin_pop <- (df$origin_res_pop - mean(df$origin_res_pop)) / sd(df$origin_res_pop)
df$z_destination_pop <- (df$destination_res_pop - mean(df$destination_res_pop)) / sd(df$destination_res_pop)
df$z_d <- (df$length_km - mean(df$length_km)) / sd(df$length_km)
```

```{r}
df <- df %>%
  group_by(monthyear)

## Partition into smaller datasets
by_month <- df  %>% 
  partition(cluster)

## Data frame for prediction
pred_df <-with(df, data.frame(z_d = mean(z_d), 
                               origin_destination_class = factor(1:100),
                               z_origin_pop = mean(z_origin_pop),
                               z_destination_pop = mean(z_destination_pop),
                               day = median(day),
                               hour = 2,
                               wd = 0, 
                               z_score = 2 ) )


rm(df)
gc()
```

## Modelling 

Model 1
```{r}
eq <- mov_prop ~ 
 z_d + origin_destination_class + # pair part 
 z_origin_pop + # origin part
 z_destination_pop + # destination_part 
 day + hour + wd + # time part
 z_score # facebook
```


```{r}
system.time({

  models <- by_month %>% 
    do(model = glm(mov_prop ~ z_d + origin_destination_class + z_origin_pop + z_destination_pop + day + hour + wd + z_score, data = ., family = binomial("logit"), weights = start_pop))

})

rm(by_month)
gc()
```


```{r}

```


