---
title: "Regression Modelling Using Facebook Data"
subtitle: "Prediction"
author: Francisco Rowe
output: html_notebook
---

Dependencies
```{r, message=FALSE, warning=FALSE}
#data wrangling
library(multidplyr) 
library(tidyverse) 
library(dplyr) 
# estimating mixed effects models 
library(lme4) 
library(merTools) 
#library(glmmTMB) 
#library(nlme)
#library(rstanarm)
# data visualisation 
library(viridis)
library(viridisLite)
library(ggthemes)
library(ggpubr)
  # reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
```

The code first obtains all the regression coefficients for the 2020 and 2021 periods separately, and then creates the plot.

# Monthly models for the 2020 period

## Data
A cross-section should provide a max set of 6080 * 6079 pairs of origin-destination, including intra-mobility
```{r}
rm(list=ls())

cluster <- new_cluster(12)

df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/full_period_mov_pop.rds") %>% 
  filter(date < "2021-01-01") %>% 
  select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )

# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name)) 
destination <- as.data.frame(unique(df$end_polygon_name))

str(df)
```

## Data Wrangling

Proportion of people moving
```{r}
df <- df %>% mutate(
  mov_prop = n_crisis / start_pop
) %>% 
  filter(mov_prop <= 1)
  
```


Creating area class interaction variable
```{r}
df <-  df %>% mutate(
origin_class = ordered(origin_class, 
                      levels = c("1","2","3","4","5","6","7","8","9","10")),
destination_class = ordered(destination_class, 
                           levels = c("1","2","3","4","5","6","7","8","9","10")),
wd = factor(wd,
            levels = c("Weekday", "Weekend")),
hour = factor(hour, 
              levels = c(" 00"," 08", " 16"))
)

df$origin_destination_class <- fct_cross(df$origin_class, df$destination_class)
df$day <- as.numeric(ordered(df$date))
df$month <- lubridate::month(lubridate::ymd(df$date), label=TRUE)
month <- unique(df$month)
df$monthyear = lubridate::floor_date(df$date, "month")
monthyear <- unique(df$monthyear)
```

Standardising covariates
```{r}
df$z_origin_pop <- (df$origin_res_pop - mean(df$origin_res_pop)) / sd(df$origin_res_pop)
df$z_destination_pop <- (df$destination_res_pop - mean(df$destination_res_pop)) / sd(df$destination_res_pop)
df$z_d <- (df$length_km - mean(df$length_km)) / sd(df$length_km)
```

```{r}
df <- df %>%
  group_by(monthyear)

## Partition into smaller datasets
by_month <- df  %>% 
  partition(cluster)


```

```{r}
ave_pre_df <- with(df, data.frame(
  origin_destination_class = unique(df$origin_destination_class), 
  z_d = mean(z_d),
  z_origin_pop = mean(z_origin_pop), 
  z_destination_pop = mean(z_destination_pop),
  day = median(day), 
  hour = factor(" 08", levels = c(" 00"," 08", " 16")),
  wd = factor("Weekday", levels = c("Weekday","Weekend")),
  z_score = 2))

#saveRDS(ave_pre_df, "/home/fcorowe/itinerant/human-mobility/data/fullsampleave_pre_df.rds") # df based on the full sample
rm(df)
gc()
```


## Modelling 

Model 1
```{r}
eq <- mov_prop ~ 
 z_d + origin_destination_class + # pair part 
 z_origin_pop + # origin part
 z_destination_pop + # destination_part 
 day + hour + wd + # time part
 z_score # facebook
```


```{r}
system.time({

  models <- by_month %>% 
    do(model = glm(mov_prop ~ z_d + origin_destination_class + z_origin_pop + z_destination_pop + day + hour + wd + z_score, data = ., family = binomial("logit"), weights = start_pop))

})

rm(by_month)
gc()
```

```{r}
system.time({
  
final <- models %>% 
  collect()

})

rm(models)
gc()
```

# Predicting probabilities
```{r}
rm(ave_pre_df)
# read df based on the full sample
ave_pre_df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/fullsampleave_pre_df.rds") 


pprob_df <- NULL

for (i in 1:length(final$model)){
  ave_pre_df$probs <- predict.glm(final$model[[i]], newdata = ave_pre_df, "response")
  ave_pre_df$month <- i
  pprob_df <- rbind(pprob_df, ave_pre_df[c("origin_destination_class", "probs", "month")])
}

write_csv(pprob_df, "/home/fcorowe/itinerant/human-mobility/outputs/pred_prob2020.csv")
```

# Models for 2021

```{r}
rm(list=ls())

cluster <- new_cluster(12)

df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/full_period_mov_pop.rds") %>% 
  filter(date > "2020-12-31") %>% 
  select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )

# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name)) 
destination <- as.data.frame(unique(df$end_polygon_name))

str(df)
```

## Data Wrangling

Proportion of people moving
```{r}
df <- df %>% mutate(
  mov_prop = n_crisis / start_pop
) %>% 
  filter(mov_prop <= 1)
  
```


Creating area class interaction variable
```{r}
df <-  df %>% mutate(
origin_class = ordered(origin_class, 
                      levels = c("1","2","3","4","5","6","7","8","9","10")),
destination_class = ordered(destination_class, 
                           levels = c("1","2","3","4","5","6","7","8","9","10")),
wd = factor(wd,
            levels = c("Weekday", "Weekend"))
)

df$origin_destination_class <- fct_cross(df$origin_class, df$destination_class)
df$day <- as.numeric(ordered(df$date))
df$month <- lubridate::month(lubridate::ymd(df$date), label=TRUE)
month <- unique(df$month)
df$monthyear = lubridate::floor_date(df$date, "month")
monthyear <- unique(df$monthyear)
```

Standardising covariates
```{r}
df$z_origin_pop <- (df$origin_res_pop - mean(df$origin_res_pop)) / sd(df$origin_res_pop)
df$z_destination_pop <- (df$destination_res_pop - mean(df$destination_res_pop)) / sd(df$destination_res_pop)
df$z_d <- (df$length_km - mean(df$length_km)) / sd(df$length_km)
```

```{r}
df <- df %>%
  group_by(monthyear)

## Partition into smaller datasets
by_month <- df  %>% 
  partition(cluster)


```

```{r}
ave_pre_df <- with(df, data.frame(
  origin_destination_class = unique(df$origin_destination_class), 
  z_d = mean(z_d),
  z_origin_pop = mean(z_origin_pop), 
  z_destination_pop = mean(z_destination_pop),
  day = median(day), 
  hour = factor(" 08", levels = c(" 00"," 08", " 16")),
  wd = factor("Weekday", levels = c("Weekday","Weekend")),
  z_score = 2))

rm(df)
gc()
```


## Modelling 

Model 1
```{r}
eq <- mov_prop ~ 
 z_d + origin_destination_class + # pair part 
 z_origin_pop + # origin part
 z_destination_pop + # destination_part 
 day + hour + wd + # time part
 z_score # facebook
```


```{r}
system.time({

  models <- by_month %>% 
    do(model = glm(mov_prop ~ z_d + origin_destination_class + z_origin_pop + z_destination_pop + day + hour + wd + z_score, data = ., family = binomial("logit"), weights = start_pop))

})

rm(by_month)
gc()
```

```{r}
system.time({
  
final <- models %>% 
  collect()

})

rm(models)
gc()
```

# Predicting probabilities
```{r}
rm(ave_pre_df)
# read df based on the full sample
ave_pre_df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/fullsampleave_pre_df.rds")

pprob_df <- NULL

for (i in 1:length(final$model)){
  ave_pre_df$probs <- predict.glm(final$model[[i]], newdata = ave_pre_df, "response")
  ave_pre_df$month <- i
  pprob_df <- rbind(pprob_df, ave_pre_df[c("origin_destination_class", "probs", "month")])
}

write_csv(pprob_df, "/home/fcorowe/itinerant/human-mobility/outputs/pred_prob2021.csv")
```


# Checking

Checking
```{r}
b <- coef(final$model[[1]])
p2t1 <- invlogit(b[1] + 
                 b[2] * ave_pre_df[1,2] + #distance
                 b[3] * 1 + # class
                 b[102] * ave_pre_df[1,3] + #origin pop
                 b[103] * ave_pre_df[1,4] + # dest pop
                 b[104] * ave_pre_df[1,5] + # day
                 b[105] * 1 + # hour 8
                 b[107] * 0 + # Weekend
                 b[108] * 2) # z_score

p2t1_v2 <- invlogit(-4.769019304  + 
                 -4.500850861 * 3.934572e-16 + #distance
                 4.903175518 * 1 + # class
                 -0.092583732 * -4.313269e-17 + #origin pop
                  0.155348835 * 1.93424e-17 + # dest pop
                 -0.001121228 * 262 + # day
                 0.270766336 * 1 + # hour 8
                 -0.128197430 * 0 + # Weekend
                 -0.047297819 * 2) # z_score

p3t1 <- invlogit(b[1] + 
                 b[2] * ave_pre_df[1,2] + #distance
                 b[4] * 1 + # class
                 b[102] * ave_pre_df[1,3] + #origin pop
                 b[103] * ave_pre_df[1,4] + # dest pop
                 b[104] * ave_pre_df[1,5] + # day
                 b[105] * 1 + # hour 8
                 b[107] * 0 + # Weekend
                 b[108] * 2) # z_score

p3t1_v2 <- invlogit(-4.769019304  + 
                 -4.500850861 * 3.934572e-16 + #distance
                 4.794165385 * 1 + # class
                 -0.092583732 * -4.313269e-17 + #origin pop
                  0.155348835 * 1.93424e-17 + # dest pop
                 -0.001121228 * 262 + # day
                 0.270766336 * 1 + # hour 8
                 -0.128197430 * 0 + # Weekend
                 -0.047297819 * 2) # z_score

p9t3 <- invlogit(b[1] + 
                 b[2] * ave_pre_df[1,2] + #distance
                 b[30] * 1 + # class
                 b[102] * ave_pre_df[1,3] + #origin pop
                 b[103] * ave_pre_df[1,4] + # dest pop
                 b[104] * ave_pre_df[1,5] + # day
                 b[105] * 1 + # hour 8
                 b[107] * 0 + # Weekend
                 b[108] * 2) # z_score

p9t3_v2 <- invlogit(-4.769019304  + 
                 -4.500850861 * 3.934572e-16 + #distance
                 -0.9624861 * 1 + # class
                 -0.092583732 * -4.313269e-17 + #origin pop
                  0.155348835 * 1.93424e-17 + # dest pop
                 -0.001121228 * 262 + # day
                 0.270766336 * 1 + # hour 8
                 -0.128197430 * 0 + # Weekend
                 -0.047297819 * 2) # z_score
```


