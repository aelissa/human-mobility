color = "black",
rot = 90,
size = 12,
family = "serif"))
dev.off()
# handle spatial data
library(sf)
# manipulate data
library(tidyverse)
library(lubridate)
library(readxl)
# create maps
library(tmap)
library(biscale) # bivariate maps
# handle spatial data
library(sf)
# manipulate data
library(tidyverse)
# population data
pop_df <- read_xls("/Users/franciscorowe/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/population/2020/ukpopestimatesmid2020on2021geography.xls",
sheet = "MYE 5",
skip = 7)
# population data
pop_df <- read_xls("/Users/franciscorowe 1/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/population/2020/ukpopestimatesmid2020on2021geography.xls",
sheet = "MYE 5",
skip = 7)
pop_df
str(pop_df)
pop_df
# local authority district boundaries
la_shp_2020 <- st_read("/Users/franciscorowe/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/Local_Authority_Districts_(May_2021)_UK_BFE_V3/LAD_MAY_2021_UK_BFE_V2.shp") %>%
# simplify boundaries
st_simplify( preserveTopology =T,
dTolerance = 500) %>% # 500m
# ensure geometry is valid
sf::st_make_valid(la_shp_simple)
# local authority district boundaries
la_shp_2020 <- st_read("/Users/franciscorowe 1/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/Local_Authority_Districts_(May_2021)_UK_BFE_V3/LAD_MAY_2021_UK_BFE_V2.shp") %>%
# simplify boundaries
st_simplify( preserveTopology =T,
dTolerance = 500) %>% # 500m
# ensure geometry is valid
sf::st_make_valid(la_shp_simple)
# local authority district boundaries
la_shp_2020 <- st_read("/Users/franciscorowe 1/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/Local_Authority_Districts_(May_2021)_UK_BFE_V3/LAD_MAY_2021_UK_BFE_V2.shp") %>%
# simplify boundaries
st_simplify( preserveTopology =T,
dTolerance = 500) %>% # 500m
# ensure geometry is valid
#sf::st_make_valid(la_shp_simple)
plot(la_shp_2020$geometry)
?st_make_valid
# local authority district boundaries
la_shp_2020 <- st_read("/Users/franciscorowe 1/Dropbox/Francisco/Research/in_progress/mig_covid_uk/data/Local_Authority_Districts_(May_2021)_UK_BFE_V3/LAD_MAY_2021_UK_BFE_V2.shp") %>%
# simplify boundaries
st_simplify( preserveTopology =T,
dTolerance = 500) %>% # 500m
# ensure geometry is valid
sf::st_make_valid(.)
plot(la_shp_2020$geometry)
la_shp_2020
shp <- left_join( st_drop_geometry(la_shp_2020),
pop_df,
by = c("LAD21CD" = "Code"))
shp
#data wrangling
library(multidplyr)
library(tidyverse)
library(dplyr)
# estimating mixed effects models
library(lme4)
library(merTools)
#library(glmmTMB)
#library(nlme)
#library(rstanarm)
# data visualisation
library(viridis)
library(viridisLite)
library(ggthemes)
library(ggpubr)
# reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
rm(list=ls())
cluster <- new_cluster(6)
df <- readRDS("/Volumes/ITINERANT/pre-processed-movements/modelling/full_period_mov_pop.rds") %>%
filter(date < "2020-04-30") %>%
select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )
rm(list=ls())
cluster <- new_cluster(6)
df <- readRDS("/Volumes/ITINERANT/pre-processed-movements/modelling/full_period_mov_pop.rds") %>%
filter(date < "2020-04-30") %>%
select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )
# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name))
destination <- as.data.frame(unique(df$end_polygon_name))
str(df)
df <- df %>% mutate(
mov_prop = n_crisis / start_pop
) %>%
filter(mov_prop <= 1)
df <-  df %>% mutate(
origin_class = ordered(origin_class,
levels = c("1","2","3","4","5","6","7","8","9","10")),
destination_class = ordered(destination_class,
levels = c("1","2","3","4","5","6","7","8","9","10")),
wd = factor(wd,
levels = c("Weekday", "Weekend"))
)
df$origin_destination_class <- fct_cross(df$origin_class, df$destination_class)
df$day <- as.numeric(ordered(df$date))
df$month <- lubridate::month(lubridate::ymd(df$date), label=TRUE)
month <- unique(df$month)
df$monthyear = lubridate::floor_date(df$date, "month")
monthyear <- unique(df$monthyear)
df$z_origin_pop <- (df$origin_res_pop - mean(df$origin_res_pop)) / sd(df$origin_res_pop)
df$z_destination_pop <- (df$destination_res_pop - mean(df$destination_res_pop)) / sd(df$destination_res_pop)
df$z_d <- (df$length_km - mean(df$length_km)) / sd(df$length_km)
df <- df %>%
group_by(monthyear)
## Partition into smaller datasets
by_month <- df  %>%
partition(cluster)
rm(df)
gc()
eq <- mov_prop ~
z_d + origin_destination_class + # pair part
z_origin_pop + # origin part
z_destination_pop + # destination_part
day + hour + wd + # time part
z_score # facebook
system.time({
models <- by_month %>%
do(model = glm(mov_prop ~ z_d + origin_destination_class + z_origin_pop + z_destination_pop + day + hour + wd + z_score, data = ., family = binomial("logit"), weights = start_pop))
})
rm(by_month)
gc()
?do
?multidplyr
df_prob <-with(df, data.frame(z_d = mean(z_d),
origin_destination_class = factor(1:100),
z_origin_pop = mean(z_origin_pop),
z_destination_pop = mean(z_destination_pop),
day = median(day),
hour = 3,
wd = 0,
z_score = 2 ) )
?predict
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*1)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*2)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*3)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*4)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*5)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*1)
round(0.3518666, 2)
round(0.3518666, 3)
rm(list=ls())
rm(list=ls())
long_df2020 <- read_csv("/Users/Franciscorowe 1/Dropbox/Francisco/Research/in_progress/itinerant/human-mobility/outputs/modelling/glm_coeff2020_class.csv")
rm(list=ls())
long_df2020 <- read_csv("/Users/Franciscorowe/Dropbox/Francisco/Research/in_progress/itinerant/human-mobility/outputs/modelling/glm_coeff2020_class.csv")
long_df2021 <- read_csv("/Users/Franciscorowe/Dropbox/Francisco/Research/in_progress/itinerant/human-mobility/outputs/modelling/glm_coeff2021_class.csv")
long_df <- rbind(long_df2020, long_df2021)
long_df
?predict.glm
long_df
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + 0.2618*3)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*3)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*2)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*1)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -1.34020*2)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -1.55146*3)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*2)
invlogit (-3.98998 + 0.00226*588 + 0.80404*3.39 + -0.67544*3)
library(aod)
install.packages("aod")
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
rm(list=ls())
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
rm(list=ls())
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
## view the first few rows of the data
head(mydata)
summary(mydata)
sapply(mydata, sd)
mydata$rank <- factor(mydata$rank)
mylogit <- glm(admit ~ gre + gpa + rank, data = mydata, family = "binomial")
summary(mylogit)
rm(list=ls())
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
## view the first few rows of the data
head(mydata)
mydata <- mydata %>% mutate(
class = ln(gre) %>%
Hmisc::cut2( g = 4)
)
#data wrangling
library(multidplyr)
library(tidyverse)
library(dplyr)
# estimating mixed effects models
library(lme4)
library(merTools)
#library(glmmTMB)
#library(nlme)
#library(rstanarm)
# data visualisation
library(viridis)
library(viridisLite)
library(ggthemes)
library(ggpubr)
# reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
library(aod) # example data from ucla
mydata <- mydata %>% mutate(
class = ln(gre) %>%
Hmisc::cut2( g = 4)
)
library(Hmisc)
mydata <- mydata %>% mutate(
class = ln(gre) %>%
Hmisc::cut2( g = 4)
)
mydata <- mydata %>% mutate(
class = gre %>%
Hmisc::cut2( g = 4)
)
mydata <- mydata %>% mutate(
class = log(gre) %>%
Hmisc::cut2( g = 4)
)
mydata
cluster <- new_cluster(6)
mydata <- mydata %>%
group_by(class)
by_class <- mydata  %>%
partition(cluster)
system.time({
models <- by_class %>%
do(model = glm(admit ~ gre + gpa + rank, data = ., family = binomial("logit")))
})
system.time({
final <- models %>%
collect()
})
final$model[[1]]
final$model[[2]]
final$model[[3]]
class(final$model[[3]])
probs<-NULL
for (i in length(final$model)){
newdata$probs <- predict(final$model[[i]], newdata = newdata, "response")
newdata$class <- i
probs <- rbind(probs, newdata[c("rank", "probs")])
}
newdata1 <- with(mydata, data.frame(gre = mean(gre), gpa = mean(gpa), rank = factor(1:4)))
## view data frame
newdata1
probs<-NULL
for (i in length(final$model)){
newdata$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata$class <- i
probs <- rbind(probs, newdata[c("rank", "probs")])
}
summary(mydata)
sapply(mydata, sd)
rm(list=ls())
mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
## view the first few rows of the data
head(mydata)
summary(mydata)
sapply(mydata, sd)
mydata$rank <- factor(mydata$rank)
mylogit <- glm(admit ~ gre + gpa + rank, data = mydata, family = "binomial")
summary(mylogit)
newdata1 <- with(mydata, data.frame(gre = mean(gre), gpa = mean(gpa), rank = factor(1:4)))
## view data frame
newdata1
cluster <- new_cluster(6)
mydata <- mydata %>% mutate(
class = log(gre) %>%
Hmisc::cut2( g = 4)
)
cluster <- new_cluster(6)
mydata <- mydata %>%
group_by(class)
## Partition into smaller datasets
by_class <- mydata  %>%
partition(cluster)
system.time({
models <- by_class %>%
do(model = glm(admit ~ gre + gpa + rank, data = ., family = binomial("logit")))
})
system.time({
final <- models %>%
collect()
})
probs<-NULL
for (i in length(final$model)){
newdata$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata$class <- i
probs <- rbind(probs, newdata[c("rank", "probs")])
}
probs<-NULL
for (i in length(final$model)){
newdata$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata$class <- i
probs <- rbind(probs, newdata[c("rank", "probs")])
}
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
probs <- rbind(probs, newdata1[c("rank", "probs")])
}
probs
newdata1
probs
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$index <- i
probs <- rbind(probs, newdata1[c("rank", "probs")])
}
probs
newdata1
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$index <- i
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
}
probs
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response")
newdata1
newdata1 <- with(mydata, data.frame(gre = mean(gre), gpa = mean(gpa), rank = factor(1:4)))
## view data frame
newdata1
newdata1
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response")
newdata1
newdata1$index <- 1
newdata1
newdata1$probs <- predict(final$model[[2]], newdata = newdata1, "response")
newdata1
newdata1$index <- 2
newdata1
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$index <- i
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
}
probs
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response")
newdata1$index <- 1
newdata1
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
probs
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$index <- i
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
}
probs
x <- rbind(probs, newdata1[c("rank", "probs", "index")])
probs
newdata1
newdata1 <- with(mydata, data.frame(gre = mean(gre), gpa = mean(gpa), rank = factor(1:4)))
## view data frame
newdata1
probs<-NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$index <- i
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
}
probs
probs <- NULL
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response")
newdata1$index <- 1
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
probs
newdata1$probs <- predict(final$model[[2]], newdata = newdata1, "response")
newdata1$index <- 2
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
probs
newdata1$probs <- predict(final$model[[3]], newdata = newdata1, "response")
newdata1$index <- 3
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
probs
newdata1$probs <- predict(final$model[[4]], newdata = newdata1, "response")
newdata1$index <- 4
probs <- rbind(probs, newdata1[c("rank", "probs", "index")])
length(final$model)
probs <- NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
probs <- rbind(probs, newdata1[c("rank", "probs", "class")])
}
probs
probs <- NULL
for (i in length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(probs, newdata1[c("rank", "probs", "class")])
}
prob_df
length(final$model)
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(probs, newdata1[c("rank", "probs", "class")])
}
prob_df
1:length(final$model)
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(probs, newdata1[c("rank", "probs", "class")])
}
prob_df
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(probs, newdata1[c("rank", "probs", "class")])
}
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(prob_df, newdata1[c("rank", "probs", "class")])
}
prob_df
?predict.glm
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response", se.fit = T)
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response", se.fit = T)
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response", se.fit = TRUE)
newdata1
newdata1 <- with(mydata, data.frame(gre = mean(gre), gpa = mean(gpa), rank = factor(1:4)))
## view data frame
newdata1
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response", se.fit = TRUE)
newdata1$class <- i
prob_df <- rbind(prob_df, newdata1[c("rank", "probs", "class")])
}
newdata1
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response")
newdata1
newdata1$probs <- predict(final$model[[1]], newdata = newdata1, "response", se.fit = TRUE)
newdata1$probs <- predict.glm(final$model[[1]], newdata = newdata1, "response", se.fit = TRUE)
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response", se = TRUE)
newdata1$class <- i
prob_df <- rbind(prob_df, newdata1[c("rank", "probs", "class")])
}
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response", se.fit = TRUE)
newdata1$class <- i
prob_df <- rbind(prob_df, newdata1[c("rank", "probs", "class")])
}
probs <- NULL
for (i in 1:length(final$model)){
newdata1$probs <- predict(final$model[[i]], newdata = newdata1, "response")
newdata1$class <- i
prob_df <- rbind(prob_df, newdata1[c("rank", "probs", "class")])
}
prob_df
getwd()
#data wrangling
library(multidplyr)
library(tidyverse)
library(dplyr)
# estimating mixed effects models
library(lme4)
library(merTools)
library(glmmTMB)
library(nlme)
library(rstanarm)
# data visualisation
library(viridis)
library(viridisLite)
# reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
rm(list=ls())
cluster <- new_cluster(2)
df <- readRDS("/Volumes/ITINERANT/pre-processed-movements/modelling/full_period_mov_pop.rds") %>%
filter(date < "2020-12-30")
# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name))
destination <- as.data.frame(unique(df$end_polygon_name))
str(df)
View(origin)
getwd
getwd()
write_csv(destination, "/Users/Franciscorowe 1/Dropbox/Francisco/Research/in_progress/itinerant/human-mobility/modelling/areas.csv")
