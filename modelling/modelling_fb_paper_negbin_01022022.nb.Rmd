---
title: "Regression Modelling Using Facebook Data"
subtitle: "Negative binomial regression"
author: Francisco Rowe
output: html_notebook
---

Dependencies
```{r, message=FALSE, warning=FALSE}
#data wrangling
library(multidplyr) 
library(tidyverse) 
library(dplyr) 
# estimating mixed effects models 
library(lme4) 
library(merTools) 
library(glmmTMB) 
#library(nlme)
#library(rstanarm)
# data visualisation 
library(viridis)
library(viridisLite)
library(ggthemes)
library(ggpubr)
  # reporting regression results
library(broom)
library(broom.mixed)
library(gtsummary)
library(sjPlot)
```

The code first obtains all the regression coefficients for the 2020 and 2021 periods separately, and then creates the plot.

# Monthly models for the 2020 period

## Data
A cross-section should provide a max set of 6080 * 6079 pairs of origin-destination, including intra-mobility
```{r}
rm(list=ls())

cluster <- new_cluster(12)

df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/full_period_mov_pop.rds") %>% 
  % filter(date < "2021-01-01") %>% 
  select( -c(tile_size, start_polygon_id, end_polygon_id, country, level, is_statistically_significant, start_quadkey, end_quadkey, n_baseline, n_difference, percent_change, start_lat, start_lon, end_lat, end_lon, geometry) )

# id for unique tiles
origin <- as.data.frame(unique(df$start_polygon_name)) 
destination <- as.data.frame(unique(df$end_polygon_name))

str(df)
```

## Data Wrangling

Creating area class interaction variable
```{r}
df <-  df %>% mutate(
origin_class = ordered(origin_class, 
                      levels = c("1","2","3","4","5","6","7","8","9","10")),
destination_class = ordered(destination_class, 
                           levels = c("1","2","3","4","5","6","7","8","9","10")),
wd = factor(wd,
            levels = c("Weekday", "Weekend")),
hour = factor(hour, 
              levels = c(" 00"," 08", " 16"))
)

df$origin_destination_class <- fct_cross(df$origin_class, df$destination_class)
df$day <- as.numeric(ordered(df$date))
df$month <- lubridate::month(lubridate::ymd(df$date), label=TRUE)
month <- unique(df$month)
df$monthyear = lubridate::floor_date(df$date, "month")
monthyear <- unique(df$monthyear)
```

Standardising covariates
```{r}
df$z_origin_pop <- (df$origin_res_pop - mean(df$origin_res_pop)) / sd(df$origin_res_pop)
df$z_destination_pop <- (df$destination_res_pop - mean(df$destination_res_pop)) / sd(df$destination_res_pop)
df$z_d <- (df$length_km - mean(df$length_km)) / sd(df$length_km)
```

```{r}
df <- df %>%
  group_by(monthyear)

## Partition into smaller datasets
by_month <- df  %>% 
  partition(cluster)


```

```{r}
ave_pre_df <- with(df, data.frame(
  origin_destination_class = unique(df$origin_destination_class), 
  z_d = mean(z_d),
  z_origin_pop = mean(z_origin_pop), 
  z_destination_pop = mean(z_destination_pop),
  day = median(day), 
  hour = factor(" 08", levels = c(" 00"," 08", " 16")),
  wd = factor("Weekday", levels = c("Weekday","Weekend")),
  z_score = 2))

#saveRDS(ave_pre_df, "/home/fcorowe/itinerant/human-mobility/data/fullsampleave_pre_df.rds") # df based on the full sample
rm(df)
gc()
```


## Modelling 

Model 1
```{r}
eq <- n_crisis ~ 
 z_d + origin_destination_class + # pair part 
 z_origin_pop + # origin part
 z_destination_pop + # destination_part 
 day + hour + wd + # time part
 z_score # facebook
```


eq <- n_crisis ~
z_d + # pair part
z_origin_pop + # origin part
z_destination_pop + # destination_part
day + hour + wd + # time part
z_score + # facebook
( 1 | origin_destination_class) # random intercept

model_nb <- glmmTMB(eq,
                    data = .,
                    ziformula = ~0,
                    family = nbinom2,
                    weights = start_pop)

```{r}
system.time({

  models <- by_month %>% 
    do(model = glm(n_crisis ~ z_d + origin_destination_class + z_origin_pop + z_destination_pop + day + hour + wd + z_score, data = ., family = poisson("log"), weights = start_pop))

})

rm(by_month)
gc()
```

```{r}
system.time({
  
final <- models %>% 
  collect()

})

rm(models)
gc()
```

# Predicting flows
```{r}
rm(ave_pre_df)
# read df based on the full sample
ave_pre_df <- readRDS("/home/fcorowe/itinerant/human-mobility/data/fullsampleave_pre_df.rds") 


pflow_df <- NULL

for (i in 1:length(final$model)){
  ave_pre_df$flow <- predict.glm(final$model[[i]], newdata = ave_pre_df, "response")
  ave_pre_df$month <- i
  pflow_df <- rbind(pflow_df, ave_pre_df[c("origin_destination_class", "flow", "month")])
}

write_csv(pflow_df, "/home/fcorowe/itinerant/human-mobility/outputs/pred_prob2020.csv")
```

